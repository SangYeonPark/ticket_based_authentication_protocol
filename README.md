# ticket_based_authentication_protocol

[Anonymous Ticket-Based Authentication]
1) 과제 목적
주어진 명세 및 요구사항을 따르는 시스템의 요구분석, 설계, 구현, 시험하는 전 과정을 스스로 수행함으로써 암호화 기법과 이를 응용한 보안 프로토콜 시스템의 설계 및 구현 능력을 키운다. 

2) 과제 개요
다양한 암호화 기법들을 활용하여 맨 처음 공개키 암호화 방식으로 인증 받은 사용자가 이후 서버로부터 받은 인증티켓을 사용하여 인증 받는 프로토콜의 상세 설계와 구현

3) 프로토콜
  o. 가정
 -  인증 서버(이하 Bob)는 다수 사용자의 인증을 담당하는데, 각 사용자의 certificate를 검증하기 위해서 CA의 public key를 보유하고 있다.
 - 각 사용자는 CA에 의해 발급된 다음과 같은 certificate를 소유하고 있다. 예를 들어, Alice의 certificate는 =("Alice", Alice의 public key) 및 로 구성되어 있다. Certificate에는 소유자 명칭이 hash 함수 적용된 채 저장되어 있어, certificate를 통해서는 그 소유자(사용자)를 알 수 없다. 각 사용자의 명칭은 예측 불가능하기 때문에 forward search는 불가능하다.
-  사용자, Bob 모두 RC4, AES, RSA, SHA-2 를 각각 사용할 수 있으며, 키(key)의 길이 등은 이미 사용자와 Bob 사이에 서로 합의된 값이 존재한다.
-  키 및 nonce 값들은 모두 RC4 알고리즘에 의해 생성된다.
  o. 동작
① Alice(사용자) -> Bob: 0, Alice’s certificate    // 0 : certificate 이용한 인증 요청임을 나타냄
② Bob -> Alice:  , 
                                            // : Bob의 랜덤 값(bit sequence)들
③ Alice -> Bob:   // 이 값을 검증하여 Bob은 상대방이 certificate의 소유자임을 확인
④ Bob -> Alice:  "Alice",    
          // : Bob이 선택한(저장하고 있는) 암호화 키, : Bob이 생성한 랜덤 값
          // "Alice"),  를 합친 전체를 로 암호화하여 인증티켓(authentication ticket)이라 함
⑤ Alice -> Bob: 1, "Alice",   // 1 : 인증티켓에 의한 인증 요청임을 나타냄
⑥ Bob -> Alice:  "Alice",  
          // 인증 후 새로운 인증티켓을 Alice에게 발급함, : Bob이 생성한 랜덤 값
이후, 매번 새로운 로 위 ⑥,⑤ 과정(티켓으로 인증 요청, 인증 후 새로운 티켓 발급)을 반복
 
[설명] 
사용자 Alice가 Bob의 인증을 받는데, 첫 인증은 Alice의 certificate에 의한 것으로 Bob은 Alice의 certificate의 public 키와 쌍이 되는 private key를 알고 있는지 확인함으로써 상대방을 certificate의 소유주로 인증한다. 
  ① Alice가 첫(이전에 Bob에게 인증 받은 적이 없음) 인증을 위해 ①의 메시지를 Bob에게 보낸다.
  ② Bob은 수신한 인증서를 자신이 가지고 있는 CA의 public key를 이용하여 검증한다. 즉, 인증서의 내용 를 이용하여  을 구하고, 그 값이 인증서의 서명을 복호화 한 와 일치하는지를 확인한다. 일치하지 않으면, 적절한 오류 메시지를 출력하고 종료한다. 일치하면, ②의 메시지를 Alice에게 보낸다.
  ③ Alice는 수신한 로부터 private key를 이용하여 를 얻고, 이 값을 이용하여 로부터 을 얻는다. 이후 ③의 메시지를 Bob에게 보내어 인증을 요청한다. Bob은 수신한 내용을 로 대칭키 복호화하여 그 결과가 과 일치하는지 확인한다. 일치하지 않으면, 적절한 오류 메시지를 출력하고 종료한다. 일치하면, 상대방을 certificate의 소유주로 인정한다.
  ④ Bob은 Alice의 향후 인증을 위하여, "Alice" (Alice의 certificate로부터 얻음) 및 새로 선택한 nonce 를 master 키 (Bob만이 알고 있는 키)로 대칭키 암호화시키고, 그 결과(인증티켓) 및 를 Alice에게 전송한다.
  ⑤ Alice는 이제부터 Bob의 인증을 받기 위해 더 이상 certificate를 이용하지 않는다. Alice는 수신한 로부터 를 얻고 를 계산한 후, 인증티켓과 더불어 를 Bob에게 보냄으로써 자신에 대한 인증을 요청한다.
  ⑥ Bob은 수신한 인증티켓을 로 복호화하여, 상대방이 "Alice"임을 알고, 에 hash 함수 적용한 결과가, 상대방으로부터 수신한 와 일치하는 것을 확인한다. 일치하지 않으면, 적절한 오류 메시지를 출력하고 종료한다. 일치하면, 상대방을 이 인증티켓의 발급 대상으로 인정한다. Bob은 새로운 nonce 를 이용하여 ④의 메시지와 같은 형태의 인증티켓을 발급함으로써, 매번 새로운 인증티켓을 통하여 상대방의 인증이 가능하도록 한다.



4) 구현 방법
위 3)에서 설명한 프로토콜 및 이를 위한 메시지 생성, 수신, 수신 메시지의 검증을 위한 각종 자료구조 및 세부 알고리즘을 상세 설계하고 구현한다. 구현 시 요구 사항은 다음과 같다.

  o. 모든 통신은 인터넷 TCP/IP를 통해 이루어져야 한다. 
  o. 암/복호화 알고리즘에서 사용될 각종 키 및 hash 함수 output 등은 보안 수준 상 적당하다고 판단      되는 크기를 임의로 선택하여 사용한다.
  o. 각 사용자 및 서버 Bob은 각각 별도의 process를 생성하여 그 동작을 실현한다. 각 process는 실행 위치에 따라 IP 주소가 정해지며, 적절한 port 번호를 통해 접근 가능하다.
  o. 서버 Bob의 IP 주소 및 port 번호는 모든 사용자에게 알려져 있어야 한다(공개된 정보라고 가정함).
  o. 각 process에서 RC4 알고리즘을 사용할 때, 입력 seed key 값은 적절한 수준의 랜덤 값들을 조합하여 사용한다(예: pid, 현재시간(time_t 형태) 등을 모아서 hash 함수 적용한 결과로부터 seed key 추출). 그 결과로, 매 실행마다 새로운 nonce, key 값들이 만들어져야 한다.
  o. 사용자 인터페이스를 통하여 Alice 및 Bob의 프로토콜 각 단계 실행 명령을 받아들인다. 예를 들어,
      Alice 프로세스의 프롬프트(예: >> )에서 ‘1’을 입력하면, 위 프로토콜의 ① 단계(메시지 전송 및 수신 측의 처리)가 진행된다. 이후 Bob 프로세스의 프롬프트에서 ‘2’를 입력하면 ② 단계가 진행된다.
  o. 사용자 인터페이스를 통하여 오류 상황을 만들 수 있어야 한다. 예를 들어, Alice 프로세스의 프롬프트에 ‘1,X’ (‘1단계, 오류’의 의미)를 입력하면, 위 프로토콜의  ① 단계에서 훼손된 메시지가 전송되어야 한다. 이를 통해 수신측이 도착한 메시지 내용의 오류를 검출해 내는지를 시험한다. 
  o. 모든 보내는 메시지 및 받은 메시지는 그 보내고 받은 내용 그대로를 화면에 출력하라. 단, 암호화된 상태(0과 1의 랜덤한 sequence)의 메시지 부분은 base64로 encoding 한 결과를 화면에 출력하라. 
  o. 모든 받은 메시지에  대하여 검증 과정에서 중간 결과로 나오는 내용을 전부 화면에 그대로 출력하라. 단, 암호화된 상태(0과 1의 랜덤한 sequence)의 결과는 base64로 encoding 한 후 화면에 출력하라. 
